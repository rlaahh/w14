<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reframed</title>
    <script>
        (function(d) {
          var config = {
            kitId: 'vub7iix',
            scriptTimeout: 3000,
            async: true
          },
          h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
        })(document);
      </script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            cursor: none;
        }
        canvas { 
            display: block; 
        }

        /* ì»¤ìŠ¤í…€ ì»¤ì„œ ìŠ¤íƒ€ì¼ */
        .custom-cursor {
            width: 20px; 
            height: 20px;
            border-radius: 50%;
            background-color: #ffffff; 
            position: fixed; 
            pointer-events: none; 
            z-index: 9999; 
            transform: translate(-50%, -50%); 
            transition: transform 0.1s ease-out; 
            mix-blend-mode: difference; 
            opacity: 1; 
            will-change: transform; 
        }
        
        /* ---------------------------------- */
        /* ğŸ‘‡ ë©”ë‰´ ë°” ìŠ¤íƒ€ì¼ */
        
        /* 1. í•˜ë‹¨ ë©”ë‰´ ë°” ë‚´ë¶€ì˜ í–„ë²„ê±° ì•„ì´ì½˜ (í† ê¸€ ë²„íŠ¼ ì—­í• ) */
        .hamburger-icon {
            width: 50px; 
            height: 50px;
            background-color: #000000;
            border-radius: 50%; 
            cursor: pointer;
            z-index: 10; 
            flex-shrink: 0; 
            position: absolute; 
            left: 0;
            transition: opacity 0.3s ease; 
            display: flex; /* SVG ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•´ ì¶”ê°€ */
            justify-content: center;
            align-items: center;
        }
        .hamburger-icon:hover {
            transform: scale(1.05);
        }

        /* ğŸ’¡ SVG ì•„ì´ì½˜ ìŠ¤íƒ€ì¼ */
        .hamburger-icon img {
            width: 50%; /* SVG í¬ê¸° */
            height: 50%;
        }

        /* 2. í™•ì¥ëœ ë©”ë‰´ ë°” ì»¨í…Œì´ë„ˆ (í•˜ë‹¨ ê²€ì€ìƒ‰ ë°”) */
        .menu-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            width: 50px; 
            height: 50px; 
            background-color: #000000;
            border-radius: 30px;
            z-index: 900;
            transform: translateX(-50%);
            transition: width 0.5s ease-in-out, border-radius 0.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: flex-start; 
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* 3. ë©”ë‰´ ë§í¬ */
        .menu-links {
            display: flex;
            gap: 40px;
            opacity: 0;
            padding: 0 0px 0 40px; 
            transition: opacity 0.3s 0.3s; 
        }
        
        .menu-link {
            text-decoration: none;
            color: #f1e4ca;
            font-size: 1rem;
            white-space: nowrap;
            font-family: neue-haas-grotesk-display, sans-serif;
font-weight: 500;
font-style: normal;
        }

        /* 4. 'X' ë‹«ê¸° ë²„íŠ¼ */
        .menu-close {
            position: absolute;
            right: 0;
            width: 50px; 
            height: 50px;
            background: none;
            color: #f1e4ca;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0; 
            transition: opacity 0.3s;
        }

        /* 5. ë©”ë‰´ í™•ì¥ ìƒíƒœ */
        .menu-container.expanded {
            width: 240px; 
            border-radius: 50px; 
            justify-content: space-between; 
        }
        
        .menu-container.expanded .menu-links {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="custom-cursor" id="custom-cursor"></div>
    
    <div class="menu-container" id="menuContainer">
        <div class="hamburger-icon" id="hamburgerIcon">
            <img src="menu.svg" alt="Menu" class="menu-svg-icon">
        </div>
        
        <div class="menu-links" id="menuLinks">
            <a href="index.html" class="menu-link">Reframed</a>
            <a href="info.html" class="menu-link">Info</a>
        </div>
        <div class="menu-close" id="menuClose">
            &times;
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // ğŸ’¡ ì»¤ìŠ¤í…€ ì»¤ì„œ ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
        const customCursor = document.getElementById('custom-cursor');

        // --- 1. ê¸°ë³¸ ì„¤ì • ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); 

        const yawObject = new THREE.Object3D();
        yawObject.position.set(0, 0, 0);
        yawObject.add(camera); 
        scene.add(yawObject);  
        
        camera.position.set(0, 0, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio); 
        document.body.appendChild(renderer.domElement);

        // í™˜ê²½ ë§µ (ë°˜ì‚¬) ì„¤ì •
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, { 
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter 
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
        scene.add(cubeCamera); 

        // --- 2. ë¹› ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x0C2836, 1.0); 
        directionalLight.position.set(-0.5, 1, 1.8);
        scene.add(directionalLight);

        // --- 3. ì´ë¯¸ì§€ íŒ¨ë„ ìƒì„± ---
        const imageUrls = [];
        const totalImageCount = 30; 
        for (let i = 1; i <= totalImageCount; i++) {
            imageUrls.push(`web-source/${i}.jpg`); 
        }

        const textureLoader = new THREE.TextureLoader();

        const sphereRadius = 8; 
        const numLayers = 5; 
        const imagesPerLayer = Math.ceil(totalImageCount / numLayers); 
        const layerSpacingAngle = Math.PI * 0.10;
        
        const phiLayers = [
            Math.PI * 0.5 - layerSpacingAngle * 2,
            Math.PI * 0.5 - layerSpacingAngle * 1,
            Math.PI * 0.5,
            Math.PI * 0.5 + layerSpacingAngle * 1,
            Math.PI * 0.5 + layerSpacingAngle * 2
        ];
        
        const imageMeshes = [];
        const imageUrlsMap = new Map(); 

        const targetPositions = []; 
        let animationProgress = 0; 
        const animationDuration = 200; 
        
        // ğŸ’¡ 5. ì»¤ì„œ ìƒíƒœ ë³€ìˆ˜ (í•¸ë“¤ë§ ì‹œ ì»¤ì„œ ëª¨ì–‘ ë³€ê²½ì„ ìœ„í•´)
        let isOverClickable = false;

        imageUrls.forEach((url, index) => {
            textureLoader.load(url, (texture) => {
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false; 

                const aspectRatio = texture.image.width / texture.image.height;
                const maxDimension = 2.0; 
                let planeWidth, planeHeight;

                if (aspectRatio >= 1) { 
                    planeWidth = maxDimension;
                    planeHeight = planeWidth / aspectRatio; 
                } else { 
                    planeHeight = maxDimension;
                    planeWidth = planeHeight * aspectRatio; 
                }

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: 1 }); 
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.scale.set(0, 0, 0); 
                
                const fileNameMatch = url.match(/(\d+)\.jpg$/);
                let targetPage;

                if (fileNameMatch && fileNameMatch[1]) {
                    const imageNumber = fileNameMatch[1];
                    targetPage = `${imageNumber}.html`;
                } else {
                    targetPage = `page_default.html`; 
                    console.warn(`íŒŒì¼ëª…ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ì–´ ê¸°ë³¸ URLì„ ì‚¬ìš©í•©ë‹ˆë‹¤: ${url}`);
                }

                imageUrlsMap.set(mesh, targetPage); 
                imageMeshes.push(mesh); 

                // ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                const layerIndex = Math.floor(index / imagesPerLayer);
                const phi = phiLayers[layerIndex];
                const indexInLayer = index % imagesPerLayer;
                
                let startOffset = 0;
                if (layerIndex % 2 !== 0) { 
                    startOffset = (Math.PI / imagesPerLayer) / 2;
                }
                
                const angleIncrement = (indexInLayer / imagesPerLayer) * Math.PI;
                const theta_final_corrected = angleIncrement + startOffset + (Math.PI / 1.8); 

                const finalPosition = new THREE.Vector3().setFromSphericalCoords(sphereRadius, phi, theta_final_corrected);
                targetPositions.push(finalPosition); 
                
                // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (ì¹´ë©”ë¼ ì• ì¤‘ì•™)
                mesh.position.set(0, 0, -5); 

                mesh.renderOrder = 0; 
                scene.add(mesh);
            });
        });

        // --- 4. ì»¤ìŠ¤í…€ 3D ëª¨ë¸ ë¡œë“œ ---
        const gltfLoader = new GLTFLoader();
        let controller; 
        
        gltfLoader.load(
            'model.glb', 
            (gltf) => {
                const model = gltf.scene;

                model.traverse((child) => {
                    if (child.isMesh) {
                        const originalMaterial = child.material;
                        if (originalMaterial.isMeshStandardMaterial) {
                            originalMaterial.envMap = cubeRenderTarget.texture; 
                            originalMaterial.needsUpdate = true;
                            originalMaterial.depthTest = true; 
                            child.renderOrder = 0; 
                        }
                    }
                });

                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const maxAxis = Math.max(size.x, size.y, size.z);
                const targetScale = 2.2 / maxAxis; 
                const scaleMultiplier = 2; 
                const finalScale = targetScale * scaleMultiplier;

                model.scale.set(finalScale, finalScale, finalScale);
                model.position.x -= center.x * finalScale;
                model.position.y -= center.y * finalScale;
                model.position.z -= center.z * finalScale; 

                const container = new THREE.Object3D();
                container.add(model);
                
                container.position.set(0, 0, -5); 

                controller = container; 
                camera.add(controller);
                console.log("ëª¨ë¸ ë¡œë“œ ì™„ë£Œ"); 
            },
            undefined,
            (error) => {
                console.error('ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error);
            }
        );
        
        // --- 5. ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  ë° Raycaster ---
        const raycaster = new THREE.Raycaster();
        const mouseVector = new THREE.Vector2();
        let mouseX = 0;
        let mouseY = 0;
        
        // ğŸ’¡ 6. ì»¤ìŠ¤í…€ ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        const updateCustomCursor = (x, y) => {
            customCursor.style.left = `${x}px`;
            customCursor.style.top = `${y}px`;
        };

        function onMouseMove(event) {
            // ğŸ’¡ ì „ì—­ ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updateCustomCursor(event.clientX, event.clientY);
            
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Raycaster ì—…ë°ì´íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ìœ„ì— ìˆëŠ”ì§€ ì²´í¬)
            mouseVector.x = mouseX;
            mouseVector.y = mouseY;
            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObjects(imageMeshes);
            
            const newIsOverClickable = intersects.length > 0;
            
            if (newIsOverClickable !== isOverClickable) {
                isOverClickable = newIsOverClickable;
                
                // ğŸ’¡ ì»¤ì„œê°€ í´ë¦­ ê°€ëŠ¥í•œ ìš”ì†Œ ìœ„ì— ìˆì„ ë•Œ ëª¨ì–‘ ë³€ê²½
                if (isOverClickable) {
                    customCursor.style.transform = 'translate(-50%, -50%) scale(1.5)';
                } else {
                    customCursor.style.transform = 'translate(-50%, -50%) scale(1)';
                }
            }
        }

        function onMouseClick(event) {
            mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouseVector, camera);

            const intersects = raycaster.intersectObjects(imageMeshes);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const targetUrl = imageUrlsMap.get(intersectedObject);

                if (targetUrl) {
                    console.log(`í˜ì´ì§€ ì´ë™: ${targetUrl}`);
                    window.location.href = targetUrl; 
                }
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        
        // ğŸ’¡ í„°ì¹˜ ì´ë²¤íŠ¸ ì²˜ë¦¬ (í„°ì¹˜ì—ì„œë„ ì»¤ì„œ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸)
        window.addEventListener('touchmove', (event) => {
            if (event.touches.length > 0) {
                updateCustomCursor(event.touches[0].clientX, event.touches[0].clientY);
            }
            // Three.js ë¡œì§ì€ mousemoveì™€ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
            onMouseMove({ 
                clientX: event.touches[0].clientX, 
                clientY: event.touches[0].clientY 
            });
        }, { passive: true });


        // --- 6. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ (ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„ êµ¬í˜„) ---
        function animate() {
            requestAnimationFrame(animate);

            // ì´ë¯¸ì§€ í¼ì¹¨ ì• ë‹ˆë©”ì´ì…˜ (ìœ„ì¹˜, í¬ê¸°, íˆ¬ëª…ë„)
            if (animationProgress < animationDuration) {
                animationProgress++;
                const ratio = animationProgress / animationDuration; 
                const easedRatio = 1 - Math.pow(1 - ratio, 3); 
                
                imageMeshes.forEach((mesh, index) => {
                    const startPosition = new THREE.Vector3(0, 0, -5); 
                    const targetPosition = targetPositions[index]; 

                    mesh.position.lerpVectors(startPosition, targetPosition, easedRatio);
                    mesh.scale.setScalar(easedRatio);
                    mesh.lookAt(0, 0, 0); 
                });
            }


            // 1. ì¹´ë©”ë¼(ì‹œì„ ) íšŒì „
            const targetCameraRotY = -mouseX * (Math.PI / 4); 
            const targetCameraRotX = mouseY * (Math.PI / 6); 

            yawObject.rotation.y += (targetCameraRotY - yawObject.rotation.y) * 0.05;
            camera.rotation.x += (targetCameraRotX - camera.rotation.x) * 0.05;


            // 2. ë¡œê³ (ëª¨ë¸) íšŒì „
            if (controller) {
                const targetLogoRotY = mouseX * 0.5; 
                const targetLogoRotX = -mouseY * 0.5;

                controller.rotation.y += (targetLogoRotY - controller.rotation.y) * 0.1;
                controller.rotation.x += (targetLogoRotX - controller.rotation.x) * 0.1;

                // 3. í™˜ê²½ ë§µ ì—…ë°ì´íŠ¸ (ë°˜ì‚¬ íš¨ê³¼)
                controller.visible = false;
                
                cubeCamera.position.copy(yawObject.position);
                cubeCamera.rotation.copy(yawObject.rotation); 
                
                cubeCamera.update(renderer, scene); 
                controller.visible = true;
            }

            renderer.render(scene, camera);
        }
        animate();

        // --- 7. ì°½ í¬ê¸° ë³€ê²½ ëŒ€ì‘ ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // --- 8. ë©”ë‰´ ë°” ë¡œì§ ---
        const hamburgerIcon = document.getElementById('hamburgerIcon');
        const menuContainer = document.getElementById('menuContainer');
        const menuClose = document.getElementById('menuClose');
        
        function toggleMenu() {
            const isExpanded = menuContainer.classList.toggle('expanded');
            
            if (isExpanded) {
                 // í™•ì¥ë˜ë©´ ë‹«ê¸° ë²„íŠ¼ì´ ë³´ì„
                 menuClose.style.opacity = '1';
                 menuClose.style.pointerEvents = 'auto';
                 hamburgerIcon.style.opacity = '0'; // í–„ë²„ê±° ì•„ì´ì½˜ ìˆ¨ê¹€
                 hamburgerIcon.style.pointerEvents = 'none';
            } else {
                 // ì¶•ì†Œë˜ë©´ ë‹«ê¸° ë²„íŠ¼ì´ ìˆ¨ê²¨ì§
                 menuClose.style.opacity = '0';
                 menuClose.style.pointerEvents = 'none';
                 hamburgerIcon.style.opacity = '1'; // í–„ë²„ê±° ì•„ì´ì½˜ í‘œì‹œ
                 hamburgerIcon.style.pointerEvents = 'auto';
            }
        }

        // í–„ë²„ê±° ì•„ì´ì½˜ í´ë¦­ ì‹œ ë©”ë‰´ í™•ì¥/ì¶•ì†Œ
        hamburgerIcon.addEventListener('click', toggleMenu);
        
        // 'X' ë²„íŠ¼ í´ë¦­ ì‹œ ë©”ë‰´ ì¶•ì†Œ
        menuClose.addEventListener('click', toggleMenu);

    </script>
</body>
</html>